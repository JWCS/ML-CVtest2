11/03/016 
PreSpring break; v0.1 completed. Next step fix edge problems with expansion. Effectively, have a gradient function and threshold function in play, as well as a flawed edge tracer: edge thinning & edge following prof said, finish in spring break;

14/03/2016 Decided that the changes to the code would change 100% of it. Instead of preserving old files that I would usurp with newer and better versions, I created a new repository, CVTrial2, and will make that public/github. Effectively little or none of the code will be kept, unless I find a use to copy or paste something. 
14/03/2016 Ok, I think I figured out the order now (for this attempt). First, filter, 3d. Then use a gradient operator (I first used robertson's apparently, now I'm trying sobel's), 3d. I want to take the gradient in 3d so that it will respond better to changes in color, not so in changes in intensity. From Gradient Operator (3d), I convert it into an intensity 2d matrix, with threshold. Then, if I understood this right, I expand the edges, and set up a line following algorithm. I think if I use sobel's I can turn the 2 matricies of 3d color (delX dir, delY dir), into 2 matricies of 2d data: an intensity/magnitude 2d matrix and a directional 2d matrix. Using this second matrix, I think I can write line following code. I will try to begin that on Tues. Also, Ash, if you're reading this, you need to start using github so I can help on your code. 
14/03/2016 Finished EdgeOperator, however I'm not sure about the 255/something scale, or that I should use the intensity fractions for rgb2gray for the magnitude of change for RGB mats to ImMag. Also, it was kinda generically written for multiple types of edge operators, but I'm just planning on using sobels. Threshold will need tweaking. Implementing expansion will be interesting, magnitude or logical? ImDir is in range of [-pi, pi]. Some areas need expansion & line thinning: if we could combine the two with thresholding using ImDir, maybe this could be clean. 
15/03/16 Fixed edge operator to be mean of RGB, it appears better. I haven't fixed xy notation to mn notation, as I'll need for ImDir... Almost finished Expansion, just bug fixing. That notation tho, the real trick here; 
16/03/16 I am not pleased with matlab's notation. What I could seemingly do in one place to lessen computation I appear to be unable to do here. Note: ask someone knowledge able if there is a way to skip past a performance in an array function opperating like a for loop, ex A(:,:) = f(B(:,:)); if B(m,n) = 0 or the like, since 7/8ths of the expansion matrix is zeros and does not need the computation performed on those elements. In anycase, the code for expansion in 8-connectivity works, and quickly(ish) too: around .8 to 1.2 seconds, not sure why the range. Currently main takes around 4.5 seconds. Commiting it now as finished 8-connectivity expansion. Also, I am not sure about rgb2grey intensity, but I like the more absolute change better, so I'm deleting all of that, it works without and should be unnecessary. Lastly, I'm fixing edge operator to actually point in direction of positive m and n, instead of my sudo xy directions. By the time this is commited, there is no obvious problems with that, except I haven't used ImDir yet. 
17/03/16 Begun DirExpansion. Effectively the same as Expansion, most of the code is cp. The difference is a logical mat .* to the new___Vals, where the mat is of points where the initial mat is pointing to. The logical mat I think is best woven into border(:,:). 
18/03/16 Finished DirExpansion. It isn't as tight as it could be, featuring for loops, but it doen't take too long (~2sec per) and works. Wrote an isolated point removal thing, very simple. I think I next need to thin the lines, which might be tedious. Even moreso, now I look, is figuring out the line following algorithm. The DirExpansion works well in the areas it was designed to work in, the areas with incomplete lines, but it covers the area with splotches of pixel groups with blotches of non pixel groups- need to pre-filter out these things. 
Almost finished with median filter- It improves the image a ton! Well, that and I switched also to experiment with median filter zone size 5 and sobel5 edge operator. Thresholds of somewhere around [100,130) seem to make the image quite more clear. Will try zone size 7+, just to see. Run time about .5 min
19/03/16 Cleaning up the code, the parameters, to optimalize the image for edge thinning. It needs to be done, but it looks tricky. Reading up on it while code compiles. Apparently, median filter of 7+ on a side leads to memory problems... and I have a ton of ram. So, it's confined to 3||5. I'm running with sobel5 and 5x5 median filter zone. I've tried multiple filters, but I'm not sure if it does anything significant, or at least anything I know how to take advantage of. Running with one instance. Threshold, under circumstances, is too low at 80 (no broken edges) and too high? at 120 (broken edges). Attempting to implement an algorithm to find an optimal (maybe) threshold, at least something better than mere guessing. Officially starting that edge thinning. 
26/03/16 It's been a busy week. Still learning. Have made a few things, Median Filter, but have tried hard on thinning alg, but sketchy process. I think I'm 'close', but the code has something wrong. I've read up online, & I'm better equipt to code this. I tried to use, for thinning, stentiford alg, but I didn't understand connectivity. I tried to use zhang-suen, but something implementation was wrong. So, going to the basics, a point is removed if it's there, it has >6 or <2 neighbors, and has connectivity =1 (I understand that, finally). 
1/4/16 I have been trying to thin based off of these rules: the points are taken into consideration 1 at a time, it is a point, it has between 2 and 6 neighbors, and it does not disconnect the remaining others. I thought I had it, but I accidentally was considering them all at once, which broke connectivity. And there were small bugs in the code, but learning the invalubility of im2col & reshape helped. Yet... I have finally gotten thinning to work! However, it is very slow, projected time is 2.7 hrs just for this... But it works!
14/4/2016 Semester ended. I've briefly been looking at converting the lagging part of the code to C. I've optimized it, but this part I can not avoid. There may be a different methodology that is faster, but I need to see what the time difference is when converted into C. Also, it's just good for me. I'm getting close, and now I'll have the time to finish. 
21/5/2016 Converted the code in the problematic portion of the thinning code to mex/C. Finally got it to the point of which it should output the padded image, aka the background should all work before the tricky computation begins. However, after debugging it, everytime I ran the program on a test 16x16 piece I've been using, Matlab entirely crashes. After trying to no avail, I've decided that I've spent enough time trying to do this, and I am trying it in matlab again, this time with more experience and with Zhang Wang algorithm, which utilizes a 4x4 local matrix. Once again running into connectivity errors in code, but expected that. There is a problem of deleting a point and the adjacent point, of which one of the two needed to be removed, but both could, and then both were. Since Matlab just passes through the entire matrix, it doesn't perform element to element looping unless I use for loops or a limiter within the overarching loop to prevent that. Also cleaned up some of the functions/classes. I had somethings that I thought would help me, but it can't be shown they actually help the processing of the image, such as removing isolated points and the threshold tuner. Albiet still in recycling bin. 
22/5/2016 Finished making the ZhangWangThin function. I tried it twice on the ImMag matrix. First run, after finding all available points that meet the conditions, as per the style of matlab it deleted all of them immediately. This took ~34 seconds. It produced, however, many disconnections of roughly one pixel thick, an easy remedy perhaps. I added an input boolean variable, that if true, would have it then, with the pixels to delete, iteratively go through them and remove all that were neighbors. Thus connectivity is guarenteed to be preserved. This took ~130 seconds. It produced, however, many spurs, short shoot-offs of roughly a few pixels, plus some zig-zagging. I think a combination of the two methods plus some expansion should solve the problems and finsh producing an image to acquire lines from. The bulk of this final finishing work is shifting back to the main class. 